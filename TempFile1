package com.yupi.yuaiagent.agent;


import jakarta.annotation.Resource;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.ai.openai.api.OpenAiApi;
import com.alibaba.cloud.ai.graph.agent.ReactAgent;
/**
 * ReAct (Reasoning and Acting) 模式的代理抽象类
 * 实现了思考-行动的循环模式
 */
@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j
public abstract class AssistantReActAgent extends BaseAgent {


    @Resource
    private ChatModel openAiChatModel;

    /**
     * 处理当前状态并决定下一步行动
     *
     * @return 是否需要执行行动，true表示需要执行，false表示不需要执行
     */
    public abstract boolean think();

    /**
     * 执行决定的行动
     *
     * @return 行动执行结果
     */
    public abstract String act();

    /**
     * 执行单个步骤：思考和行动
     *
     * @return 步骤执行结果
     */
    @Override
    public String step() {

        ChatResponse response = openAiChatModel.call(
                new Prompt(
                        "Generate the names of 5 famous pirates.",
                        OpenAiChatOptions.builder()
                                .model("gpt-4o")
                                .temperature(0.4)
                                .build()
                ));
        OpenAiApi openAiApi = new OpenAiApi();
        ChatModel chatModel = OpenAiChatModel.builder().openAiApi(openAiApi).defaultOptions(OpenAiChatOptions.builder()
                        .model("")
                        .temperature(1.0)
                        .topP(0.9)
                        .maxTokens(1000)
                        .build()
                        ).build();

        try {
            // 先思考
            boolean shouldAct = think();
            if (!shouldAct) {
                return "思考完成 - 无需行动";
            }
            // 再行动
            return act();
        } catch (Exception e) {
            // 记录异常日志
            e.printStackTrace();
            return "步骤执行失败：" + e.getMessage();
        }
    }

}



package com.yupi.yuaiagent.agent;

import com.yupi.yuaiagent.advisor.MyLoggerAdvisor;
import com.yupi.yuaiagent.agent.model.AgentState;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.tool.ToolCallback;
import org.springframework.stereotype.Component;

/**
 * 鱼皮的 AI 超级智能体（执行层）
 */
@Component
public class YuManus extends ToolCallAgent {

    public YuManus(ToolCallback[] allTools, ChatModel dashscopeChatModel) {
        super(allTools); // 这里的 allTools 会赋值给父类的 availableTools
        this.setName("yuManus");

        String SYSTEM_PROMPT = """
                You are YuManus, an all-capable AI assistant.
                You have various tools at your disposal to complete complex requests.
                """;
        this.setSystemPrompt(SYSTEM_PROMPT);

        String NEXT_STEP_PROMPT = """
                Select the appropriate tool. If the task is finished, call `doTerminate`.
                """;
        this.setNextStepPrompt(NEXT_STEP_PROMPT);
        this.setMaxSteps(20);

        ChatClient chatClient = ChatClient.builder(dashscopeChatModel)
                .defaultAdvisors(new MyLoggerAdvisor())
                .build();
        this.setChatClient(chatClient);
    }

    /**
     * 实现自主运行的入口方法
     */
    public String run(String userInput) {
        // 1. 初始化消息上下文
        this.getMessageList().clear();
        this.setState(AgentState.RUNNING);

        // 将用户初始输入放入消息列表
        this.getMessageList().add(new org.springframework.ai.chat.messages.UserMessage(userInput));

        // 2. 启动 Think-Act 循环 (继承自 ReActAgent 的逻辑)
        StringBuilder finalResult = new StringBuilder();
        for (int i = 0; i < getMaxSteps(); i++) {
            // 思考：判断是否需要调用工具
            boolean needAct = this.think();

            if (!needAct) {
                // 如果不需要调用工具，说明 AI 已经直接给出了回复
                finalResult.append(this.getMessageList().get(this.getMessageList().size() - 1).getText());
                break;
            }

            // 行动：执行工具调用
            String actResult = this.act();
            finalResult.append("\n执行结果：").append(actResult);

            // 检查状态是否已被 act() 改为 FINISHED
            if (this.getState() == AgentState.FINISHED) {
                break;
            }
        }
        return finalResult.toString();
    }
}
package com.yupi.yuaiagent.agent;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.stereotype.Component;

/**
 * 路由分流器
 */
@Component
public class YuManusRouter {

    private final ChatClient routerClient;
    private final YuManus yuManus;

    public YuManusRouter(ChatModel chatModel, YuManus yuManus) {
        // 使用简单的 ChatClient 进行意图识别
        this.routerClient = ChatClient.builder(chatModel).build();
        this.yuManus = yuManus;
    }

    public String handle(String userInput) {
        // 1. 路由分流：判断用户是否需要“动用工具”或“深度规划”
        String routeDecision = routerClient.prompt()
                .system("""
                        你是一个任务分拣器。分析用户需求，只输出一个词：
                        - AGENT: 如果涉及搜索、数据库查询、复杂计算或需要多步操作。
                        - CHAT: 如果只是打招呼、简单的问候、或者一般性的常识聊天。
                        """)
                .user(userInput)
                .call()
                .content()
                .toUpperCase();

        // 2. 执行分流逻辑
        if (routeDecision.contains("AGENT")) {
            // 路由到 YuManus 智能体，启动多步 ReAct 循环
            return yuManus.run(userInput);
        } else {
            // 路由到普通对话流，不启动工具调用循环，节省资源
            return routerClient.prompt().user(userInput).call().content();
        }
    }
}



